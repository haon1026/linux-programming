进程间通信的常用方式及特征
    管道：使用简单
    FIFO:非血缘关系间
    信号：开销小
    共享内存：非血缘关系间
    socket(本地套接字)：稳定

------------------------------------------------------------------------------------------------------------------------------

管道：
    实现原理：内核借助环形队列机制，使用内核缓冲区实现
    特质：
        1.伪文件
        2.管道中的数据只能一次读取
        3.数据在管道中，只能单向流动
    局限性：
        1.自己写，不能自己读
        2.数据不可以反复读
        3.单向通信（半双工通信）
        4.血缘关系进程间可用

pipe函数：
    int pipe(int fd[2]);
    功能：创建，并打开管道
    参数：
        fd[0]：读端
        fd[1]：写端
    返回值：
        成功：0
        失败：-1，errno

管道的读写行为：
    读管道：
        1.管道有数据，read返回实际读到的字节数
        2.管道无数据：
                    1）无写端，read返回 0（类似读到文件尾）
                    2）有写端，read阻塞等待
    写管道：
        1.无读端，异常终止（SIGPIPE信号导致的）
        2.有读端：
                1）管道已满，阻塞等待
                2）管道未满，返回写出的字节个数

------------------------------------------------------------------------------------------------------------------------------

pipe管道：
    用于有血缘关系的进程间通信
    父子进程间通信
    兄弟进程间通信

fifo管道：
    可以用于无血缘关系的进程间通信
    命名管道：mkfifo
    用法：
            读端：open file O_RDONLY
            写端：open file O_WRONLY

文件实现进程间通信
    打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件

------------------------------------------------------------------------------------------------------------------------------

共享内存映射：
    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
    功能：创建共享内存映射
    参数：
        addr：  指定映射区的首地址。通常传NULL,表示让系统自动分配
        length：共享内存映射区的大小    （<=文件的实际大小）
        prot：  共享内存映射区的读写属性。 PROT_READ、PROT_WRITE、PROT_WRITE|PROT_WREAD
        flags： 标注共享内存的共享属性。 MAP_SHARED、MAP_PRIVATE
        fd：    用于创建共享内存映射区的那个文件的文件描述符
        offset：偏移位置。  需是4k的整数倍  默认0，表示映射文件全部
    返回值：
        成功：映射区的首地址
        失败：MAP_FAILED（void*(-1)）， errno

    int munmap(void *addr, size_t length)
    功能：释放映射区
    参数：
        addr：mmap的返回值
        length：大小

------------------------------------------------------------------------------------------------------------------------------

使用注意事项：
    1.用于创建映射区的文件大小为0，实际指定非0大小创建映射区，报错“总线错误”
    2.用于创建映射区的文件大小为0，实际指定0大小创建映射区，报错“无效参数”

    3.用于创建映射区的文件读写属性为只读，映射区属性为读写,如果访问权限是“共享”MAP_SHARED，报错“没有权限”，如果为“私有”MAP_PRIVATE，正常运行 （9，10）
    4.创建映射区，需要read权限，只写不行。当访问权限指定为“共享”MAP_SHARED时，mmap的读写权限应该<=文件的open权限

    5.文件描述符fd，在mmap创建映射区完成后即可关闭。后续访问文件，用地址访问
    6.offset必须是4096的整数倍  （MMU映射的最小单位4K）
    7.对申请的映射区内存，不能越界访问
    8.munmap用于释放的地址，必须是mmap申请返回的地址
    9.映射区访问权限为“私有”MAP_PRIVATE，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上
    10.映射区访问权限为“私有”MAP_PRIVATE，只需要open文件时，有读权限，用于创建映射区即可

mmap函数的保险调用方式：
    1. fd = open("文件名"， O_RDWR)
    2 mmap(NULL, 有效文件大小，PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)

------------------------------------------------------------------------------------------------------------------------------

使用mmap进行父子进程间通信：
    父进程先创建映射区。open(O_RDWR) mmap(MAP_SHARED)
    指定MAP_SHARED权限
    fork()创建子进程
    一个进程读，另外一个进程写

无血缘关系进程间mmap通信：
    两个进程打开同一个文件，创建映射区
    指定MAP_SHARED权限
     一个进程写入，另外一个进程读出
     【注意】：无血缘关系进程间通信区别：
                                    mmap：数据可以重复读取
                                    fifo：数据只能一次读取

匿名映射：只能用于血缘关系进程间通信
    p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);

------------------------------------------------------------------------------------------------------------------------------

信号共性：
    简单、不能携带大量信息、满足条件才发送

信号的特质：
    信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令
    所有信号的产生及处理全部都是由 内核 完成的

信号相关的概念
    产生信号：
        1.按键产生
        2.系统调用产生
        3.软件条件产生
        4.硬件异常产生
        5.命令产生
    
    概念：
        未决：产生与递达之间的状态
        递达：产生并且送达到进程。直接被内核处理掉
        信号处理方式：执行默认处理动作、忽略、捕捉（自定义）
        阻塞信号集（信号屏蔽字）：本质是位图。用来记录信号的屏蔽状态。一旦信号被屏蔽，在解除屏蔽前，一直处于未决态
        未决信号集：本质是位图。用来记录信号的处理状态。该信号集中的信号表示，已经产生，但尚未被处理

信号4要素：
    信号使用之前，应先确定其4要素，而后再用！！！
    信号编号、信号名称、信号对应事件、信号默认处理动作

------------------------------------------------------------------------------------------------------------------------------

kill命令和kill函数
    int kill(pid_t pid, int signum)
    参数：
        pid：
            > 0：发送信号给指定进程
            = 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程
            <-1：取绝对值，杀死该绝对值所对应的进程组的所有组员
            =-1：发送信号给有权限发送的所有进程
        signum：
            待发送的信号

------------------------------------------------------------------------------------------------------------------------------

alarm函数：     （自然计时法）
    功能：定时发送SIGALRM给当前进程
    unsigned int alarm(unsigned int seconds)
    参数：
        seconds：定时秒数
    返回值：
        上次定时剩余时间
        无错误现象
    
    alarm(0)：取消闹钟
    time命令：查看程序执行时间。    实际时间=用户时间+内核时间+等待时间     -->优化瓶颈 IO

------------------------------------------------------------------------------------------------------------------------------

setitimer函数：
    功能：设置定时器（闹钟），可代替alarm函数。精度微妙us，可以实现周期定时
    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)
    参数：
        which：
            ITIMER_REAL：采用自然计时            ->  SIGALRM
            ITIMER_VIRTUAL：采用用户空间计时     ->  SIGVTALRM
            ITIMER_PROF：采用内核+用户空间计时   ->  SIGPROF  
        new_value：定时秒数
            类型：struct itimerval
                {
                    struct timeval 
                    {
                        time_t      tv_sec;
                        suseconds_t tv_usec;
                    }it_interval;               用来设定两次定时任务之间间隔的时间       
                    struct timeval 
                    {
                        time_t      tv_sec;
                        suseconds_t tv_usec;
                    }it_value;                  定时的时长
                }
        old_value：传出参数，上次定时剩余时间
    返回值：
        成功：0
        失败：-1
    
    e.g.：
        struct itimerval new_t;
        struct itimerval old_t;
        new_t.it_interval.tv_sec = 1;
        new_t.it_interval.tv_usec = 0;
        new_t.it_value.tv_sec = 0;
        new_t.it_value.tv_usec = 0;
        setitimer(&new_t, &old_t);

其他几个发信号函数：
    int raise(int sig);
    void abort(void);

------------------------------------------------------------------------------------------------------------------------------

信号集操作函数：
    sigset_t set;           自定义信号集
    sigemptyset(sigset_t *set);                清空信号集
    sigfillset(sigset_t *set);              全部置1
    sigaddset(sigset_t *set, int signum);   将一个信号添加到集合中
    sigdelset(sigset_t *set, int signum);   将一个信号从集合中移除
    sigismember(const sigset_t *set, int signum);   判断一个信号是否在集合中。在返回1，不在返回0

设置信号屏蔽字和解除屏蔽：
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
    参数：
        how：
            SIG_BLOCK   设置阻塞
            SIG_UNBLOCK 取消阻塞
            SIG_SETMASK 用自定义set替换mask
        set：自定义set
        oldset：旧有的mask

查看未决信号集：
    int sigpending(sigset_t *set);
    参数
        set：传出的未决信号集

------------------------------------------------------------------------------------------------------------------------------

信号捕捉：
    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
    参数：
        signum：注册的信号
        handler：回调函数
    返回值：
        成功：前一个回调函数指针
        失败：SIG_ERR

    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
    参数：
        signum：注册的信号
        act：注册信息
            struct sigaction {
               void     (*sa_handler)(int);                             回调函数
               void     (*sa_sigaction)(int, siginfo_t *, void *);      如果信号要传递更多信息，会用到，sa_flags也要设置成相应的值
               sigset_t   sa_mask;                                      屏蔽字
               int        sa_flags;                                     0为默认属性，执行捕捉函数期间会自动屏蔽该信号。
               void     (*sa_restorer)(void);                           
           };
        oldact：上一次注册的信息
    返回值：
        成功：0
        失败：-1


    系统调用分类：
        1、慢速系统调用：可能会使进程永远阻塞的一类，如果在阻塞期间收到一个信号，该系统调用就会被中断，不再继续执行（早期），也可以设定系统调用是否重启。如：read、write、pause、wait
        2、其他系统调用：getpid、getppid、fork

    可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRUPT不重启、SA_RESTART重启
    sa_flags还有很多可选参数：如捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号

------------------------------------------------------------------------------------------------------------------------------

信号捕捉特性：
    1、捕捉函数执行期间，信号屏蔽字由 mask --> sa_mask，捕捉函数执行结束，恢复回mask
    2、捕捉函数执行期间，本信号自动被屏蔽（sa_flags = 0）
    3、捕捉函数执行期间，被屏蔽信号多次发送，接触屏蔽后只处理一次
进程间通信的常用方式及特征
    管道：使用简单
    FIFO:非血缘关系间
    信号：开销小
    共享内存：非血缘关系间
    socket(本地套接字)：稳定

------------------------------------------------------------------------------------------------------------------------------

管道：
    实现原理：内核借助环形队列机制，使用内核缓冲区实现
    特质：
        1.伪文件
        2.管道中的数据只能一次读取
        3.数据在管道中，只能单向流动
    局限性：
        1.自己写，不能自己读
        2.数据不可以反复读
        3.单向通信（半双工通信）
        4.血缘关系进程间可用

pipe函数：
    int pipe(int fd[2]);
    功能：创建，并打开管道
    参数：
        fd[0]：读端
        fd[1]：写端
    返回值：
        成功：0
        失败：-1，errno

管道的读写行为：
    读管道：
        1.管道有数据，read返回实际读到的字节数
        2.管道无数据：
                    1）无写端，read返回 0（类似读到文件尾）
                    2）有写端，read阻塞等待
    写管道：
        1.无读端，异常终止（SIGPIPE信号导致的）
        2.有读端：
                1）管道已满，阻塞等待
                2）管道未满，返回写出的字节个数

------------------------------------------------------------------------------------------------------------------------------

pipe管道：
    用于有血缘关系的进程间通信
    父子进程间通信
    兄弟进程间通信

fifo管道：
    可以用于无血缘关系的进程间通信
    命名管道：mkfifo
    用法：
            读端：open file O_RDONLY
            写端：open file O_WRONLY

文件实现进程间通信
    打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件

------------------------------------------------------------------------------------------------------------------------------

共享内存映射：
    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
    功能：创建共享内存映射
    参数：
        addr：  指定映射区的首地址。通常传NULL,表示让系统自动分配
        length：共享内存映射区的大小    （<=文件的实际大小）
        prot：  共享内存映射区的读写属性。 PROT_READ、PROT_WRITE、PROT_WRITE|PROT_WREAD
        flags： 标注共享内存的共享属性。 MAP_SHARED、MAP_PRIVATE
        fd：    用于创建共享内存映射区的那个文件的文件描述符
        offset：偏移位置。  需是4k的整数倍  默认0，表示映射文件全部
    返回值：
        成功：映射区的首地址
        失败：MAP_FAILED（void*(-1)）， errno

    int munmap(void *addr, size_t length)
    功能：释放映射区
    参数：
        addr：mmap的返回值
        length：大小

------------------------------------------------------------------------------------------------------------------------------

使用注意事项：
    1.用于创建映射区的文件大小为0，实际指定非0大小创建映射区，报错“总线错误”
    2.用于创建映射区的文件大小为0，实际指定0大小创建映射区，报错“无效参数”

    3.用于创建映射区的文件读写属性为只读，映射区属性为读写,如果访问权限是“共享”MAP_SHARED，报错“没有权限”，如果为“私有”MAP_PRIVATE，正常运行 （9，10）
    4.创建映射区，需要read权限，只写不行。当访问权限指定为“共享”MAP_SHARED时，mmap的读写权限应该<=文件的open权限

    5.文件描述符fd，在mmap创建映射区完成后即可关闭。后续访问文件，用地址访问
    6.offset必须是4096的整数倍  （MMU映射的最小单位4K）
    7.对申请的映射区内存，不能越界访问
    8.munmap用于释放的地址，必须是mmap申请返回的地址
    9.映射区访问权限为“私有”MAP_PRIVATE，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上
    10.映射区访问权限为“私有”MAP_PRIVATE，只需要open文件时，有读权限，用于创建映射区即可

mmap函数的保险调用方式：
    1. fd = open("文件名"， O_RDWR)
    2 mmap(NULL, 有效文件大小，PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)

------------------------------------------------------------------------------------------------------------------------------

使用mmap进行父子进程间通信：
    父进程先创建映射区。open(O_RDWR) mmap(MAP_SHARED)
    指定MAP_SHARED权限
    fork()创建子进程
    一个进程读，另外一个进程写

无血缘关系进程间mmap通信：
    两个进程打开同一个文件，创建映射区
    指定MAP_SHARED权限
     一个进程写入，另外一个进程读出
     【注意】：无血缘关系进程间通信区别：
                                    mmap：数据可以重复读取
                                    fifo：数据只能一次读取

匿名映射：只能用于血缘关系进程间通信
    p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);

------------------------------------------------------------------------------------------------------------------------------

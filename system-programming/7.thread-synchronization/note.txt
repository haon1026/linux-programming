线程同步：
    协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误

数据混乱原因：
    1.资源共享（独享资源则不会）
    2.调度随机（意味着数据访问会出现竞争）
    3.线程间缺乏必要的同步机制
    前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥

锁的使用：
    建议锁！对公共数据进行保护。所有线程【应该】在访问公共数据前先拿锁再访问。但，锁本身不具备强制性

------------------------------------------------------------------------------------------------------------------------------

使用mutex（互斥量、互斥锁）一般步骤：
    1、pthread_mutex_t lock;    创建锁
    2、pthread_mutex_init;      初始化      1
    3、pthread_mutex_lock;      加锁        1--  ->  0
    4、访问共享数据（stdout）
    5、pthread_mutex_unlock;    解锁        0++  ->  1
    6、pthread_mutex_destroy;   销毁锁

    初始化互斥量：
        1.pthread_mutex_t mutex;
          pthread_mutex_init(&mutex, NULL);                 动态初始化
        2.pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER 静态初始化

    注意事项：
        尽量保证锁的粒度，越小越好。（访问共享数据前加锁，访问结束【立即】解锁）
        互斥锁，本质是结构体，可以看成整数，初值为1（pthread_mutex_init（）函数调用成功）
        加锁，--操作，阻塞线程
        结束，++操作，唤醒阻塞在锁上的线程
        try锁，尝试加锁，成功--，失败，返回，通知设置错误号EBUSY

restrict关键字：
    用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成

------------------------------------------------------------------------------------------------------------------------------

死锁：
    是使用锁不恰当导致的现象
    产生原因：
        1、同一个线程对一个锁反复lock
        2、两个线程，各自持有一把锁，请求另一把
    避免方法：
        1、保证资源的获取顺序，要求每个线程获取资源的顺序一致
        2、当得不到所有所需资源时，放弃已经获得的资源，等待
------------------------------------------------------------------------------------------------------------------------------

读写锁：
    锁只有一把。以读方式给数据加锁--读锁。以写方式给数据加锁--写锁
    读共享，写独占
    写锁优先级高
    相较于互斥量而言，当读线程多的时候，提高访问效率

    pthread_rwlock_t rwlock
    pthread_rwlock_init(&rwlock)
    pthread_rwlock_wrlock(&rwlock)
    pthread_rwlock_rdlock(&rwlock)
    pthread_rwlock_unlock(&rwlock)
    pthread_rwlock_destroy(&rwlock)

------------------------------------------------------------------------------------------------------------------------------

条件变量：
    本身不是锁！    但是通常结合锁来使用    mutex
    pthread_cond_t cond
    初始化条件变量：
        1.pthread_cond_t cond
          pthread_cond_init(&cond, NULL);                   动态初始化
        2.pthread_cond_t cond = PTHREAD_COND_INITIALIZER    静态初始化
    pthread_cond_destroy(&cond)

    pthread_cond_wait(&cond, &mutex)    阻塞等待一个条件变量满足
    作用：
        1、阻塞等待条件变量cond满足
        2、释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex)
            （1.2两部为一个原子操作（不可再分），两部会同时完成，不可被中断）
        3、当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&mutex)

    pthread_cond_signal()   唤醒阻塞在条件变量上的（至少）一个线程
    pthread_cond_broadcast()    唤醒阻塞在条件变量上的所有线程
    【借助条件变量实现生产者与消费者模型】

------------------------------------------------------------------------------------------------------------------------------

信号量：    （应用于进程、线程间通信）
    相当于初始值为N的互斥量。    N值：表示可以同时访问共享数据区的线程数
    函数：
        sem_t sem;
        int sem_init(sem_t *sem, int pshared, unsigned int value)
        参数：
            sem：信号量
            pshared：0，用于线程间同步  1、用于进程间同步
            value：N值（指定同时访问的线程数）
        
        sem_destroy()
        sem_wait()      一次调用，做一次--操作，当信号量的值为0时，再次--就会阻塞（对比pthread_mutex_lock）
        sem_post()      一次调用，做一次++操作，当信号量的值为N时，再次++就会阻塞（对比pthread_mutex_unlock）
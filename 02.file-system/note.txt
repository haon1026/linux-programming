inode：
	本质：结构体（存放文件属性信息、权限、类型、用户、时间（访问时间，内容修改时间，属性修改时间）、盘块位置...）

dentry：
	本质：结构体（文件名、inode号...）

------------------------------------------------------------------------------------------------------------------------------

stat函数：
	int stat(const char *path, struct stat *buf)
	功能：获取文件信息
	参数：
		path：文件路径
		buf：传出参数，存放文件属性
	返回值：
		成功：0
		失败：-1 errno
	获取文件大小：buf.st_size
	获取文件类型：buf.st_mode
	获取文件权限：buf.st_mode
	符号穿透：stat会，lstat不会

------------------------------------------------------------------------------------------------------------------------------

link函数：
	创建一个目录项（硬链接）
unlink函数
	删除一个目录项
	注意：linux下删除文件的机制：不断将 nlink-1，直至减到0为止。无目录项对应的文件，将会被操作系统择机释放（删除文件，从某种意义上来说，只是让文件具备了被释放的条件）
	特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放，要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉

------------------------------------------------------------------------------------------------------------------------------

目录操作函数：
	DIR * opendir(char *name);
	int closedir(DIR *dp);
	struct dirent *readdir(DIR *);

------------------------------------------------------------------------------------------------------------------------------

递归遍历目录：ls -R
	1.判断命令行参数，获取用户要查询的目录名 argv[]
		argc == 1 --> ./
	2.判断用户指定的是否是目录 stat S.ISDIR()	封装函数 isFile
	2.读目录：
		opendir(dir)
		while(readdir())
		{
			普通文件，直接打印
			目录：
				拼接目录访问绝对路径 sprintf(path, "%s%s", dir, d_name)
				递归调用自己 --> opendir readdir closedir
		}
		closedir()

------------------------------------------------------------------------------------------------------------------------------

dup和dup2：
	int dup(int oldfd)					
	功能：文件描述符复制
	参数：
		oldfd：已有文件描述符
	返回值：
		成功：新文件描述符
		失败：-1
		
	int dup2(int oldfd, int newfd);		
	功能：文件描述符复制、重定向
	参数：
		oldfd：已有文件描述符
		newfd：指定的文件描述符
	返回值：
		成功：指定的文件描述符
		失败：-1

------------------------------------------------------------------------------------------------------------------------------

fcntl函数实现dup：
	int fcntl(int fd, int cmd, ...)
	参数：
		cmd：F_DUPFD
		参3：指定描述符
	返回值：	
		被占用，返回最小可用的
		未被占用的，返回≥该值的文件描述符
		
